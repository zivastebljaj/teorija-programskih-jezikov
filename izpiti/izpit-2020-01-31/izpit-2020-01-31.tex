\documentclass[arhiv]{izpit}
\usepackage{amssymb}
\usepackage{fouriernc}

\begin{document}

\newcommand{\bnfis}{\mathrel{{:}{:}{=}}}
\newcommand{\bnfor}{\;\mid\;}
\newcommand{\fun}[2]{\lambda #1. #2}
\newcommand{\conditional}[3]{\mathtt{if}\;#1\;\mathtt{then}\;#2\;\mathtt{else}\;#3}
\newcommand{\whileloop}[2]{\mathtt{while}\;#1\;\mathtt{do}\;#2}
\newcommand{\recfun}[3]{\mathtt{rec}\;\mathtt{fun}\;#1\;#2. #3}
\newcommand{\boolty}{\mathtt{bool}}
\newcommand{\funty}[2]{#1 \to #2}
\newcommand{\tru}{\mathtt{true}}
\newcommand{\fls}{\mathtt{false}}
\newcommand{\tbool}{\mathtt{bool}}
\newcommand{\tand}{\mathbin{\mathtt{and}}}
\newcommand{\tandalso}{\mathbin{\mathtt{andalso}}}
\newcommand{\imp}{\textsc{imp}}
\newcommand{\skp}{\mathtt{skip}}
\newcommand{\nadaljevanje}{\dodatek{\newpage\noindent\emph{(nadaljevanje rešitve \arabic{naloga}. naloge)}}}
\izpit
  [ucilnica=P02]{Teorija programskih jezikov: 1. izpit}{31.\ januar 2020}{
  Čas pisanja je 180 minut. Doseči je možno 80 točk. Veliko uspeha!
}
\dodatek{
  \newpage
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga[\tocke{20}]
V $\lambda$-računu lahko vsako naravno število $n$ predstavimo s \emph{Churchevim naravnim številom}
\[
  e_n = \fun{s} \fun{z} \underbrace{s (s (\cdots (s}_n \; z) \cdots))
\]
\podnaloga Zapišite vse korake v evalvaciji izraza $(e_2 \; (\fun{n} 2 * n)) \; 1$.
\podnaloga Napišite funkcijo $f$, ki vsako Churchevo naravno število pretvori v običajno naravno število. Veljati mora torej $f \; e_n \leadsto^* n$.
\podnaloga Izračunajte najbolj splošen tip izraza $e_2$.
\nadaljevanje
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga[\tocke{20}]
Operacijsko semantiko programskega jezika {\imp} z ukazi
\[
  c \bnfis
  \conditional{b}{c_1}{c_2} \bnfor
  \whileloop{b}{c} \bnfor
  c_1; c_2 \bnfor
  \ell := e \bnfor
  \skp
\]
smo običajno podali z velikimi koraki, torej z relacijami
\[
  s, e \Downarrow n, \qquad s, b \Downarrow p, \qquad s, c \Downarrow s',
\]
vendar bi lahko podobno storili tudi z malimi koraki
\[
  s, e \leadsto e', \qquad s, b \leadsto b', \qquad s, c \leadsto s', c'
\]
Pri tem aritmetični izrazi s koraki končajo, ko dosežejo število $n$, Booleovi izrazi takrat, ko dosežejo logično vrednost $p$, ukazi pa takrat, ko dosežejo $s, \skp$.

\podnaloga Podajte pravila, ki določajo relacijo $s, c \leadsto s', c'$. Pravil za aritmetične in Booleove izraze vam ni treba podajati.

\newcommand{\interleave}[2]{#1 \leftrightharpoons #2}
\podnaloga Jezik {\imp} razširimo s prepletenim izvajanjem $\interleave{c_1}{c_2}$, ki najprej izvede en korak ukaza $c_1$, nato en korak ukaza $c_2$, nato naslednji korak ukaza $c_1$ in tako naprej. Če je ukaz, ki je na vrsti, z izvajanjem končal, do konca izvedemo preostali ukaz. Zapišite dodatna pravila, s katerimi morate razširiti operacijsko semantiko.
\prostor[2]

\nadaljevanje
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga[\tocke{20}]
\newcommand{\fix}{\mathit{fix}}
Dana naj bo domena $D$ in naj bo $\fix \colon [D \to D] \to D$ preslikava, ki vsaki zvezni preslikavi $f \colon D \to D$ priredi njeno najmanjšo fiksno točko $\fix(f) \in D$. Dokažite, da je preslikava $\fix$ zvezna.

\nadaljevanje
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\naloga[\tocke{20}]
\newcommand{\good}[1]{\mathcal{D}_{#1}}
Imejmo $\lambda$-račun samo z Booleovimi vrednostmi in funkcijami
\[
  e \bnfis
  x \bnfor
  \tru \bnfor
  \fls \bnfor
  \conditional{e}{e_1}{e_2} \bnfor
  \fun{x}{e} \bnfor
  e_1 \; e_2
\]
ter z običajnimi pravili za neučakano operacijsko semantiko malih korakov in določanje tipov. Ker v jeziku nimamo rekurzije, vsak program, ki ima tip, tudi konvergira, vendar preprosta indukcija žal ne zadošča za dokaz.\footnote{Za čast in slavo lahko poiščete izraz $e$, ki divergira, torej da obstaja neskončno zaporedje
$e \leadsto e_1 \leadsto e_2 \leadsto \cdots$
}


Namesto tega za vsak tip $A$ definiramo množico \emph{dobrih izrazov}~$\good{A}$ kot
%
\begin{align*}
  \good{\boolty} &=
    \big\{ e \mid (e \leadsto^* \tru) \lor (e \leadsto^* \fls) \big\} &
  \good{\funty{A_1}{A_2}} &=
    \big\{ e \mid \forall e' \in \good{A_1}. e \; e' \in \good{A_2} \big\}
\end{align*}
%
in dokaz razbijemo na tri dele\ldots

\podnaloga
Dokažite, da vsi dobri izrazi konvergirajo, torej da za vsak tip $A$ in vsak $e \in \good{A}$ obstaja vrednost~$v$, da velja $e \leadsto^* v$.

\podnaloga
Dokažite, da za vsak tip $A$ iz $e \leadsto e'$ in $e' \in \good{A}$ sledi $e \in \good{A}$.

\podnaloga
Dokažite, da za vsak izraz $x_1 : A_1, \dots, x_n : A_n \vdash e : A$ in vse vrednosti $v_1 \in \good{A_1}, \dots, v_n \in \good{A_n}$ velja tudi $e[v_1 / x_1, \dots, v_n / x_n] \in \good{A}$. Torej: vsak izraz, ki ima tip, je dober, če vse proste spremenljivke zamenjamo z dobrimi vrednostmi.

\nadaljevanje

\end{document}
